---
title: Platform Customization
description: Recommendations for Xperience by Kentico platform customization
---

import Recommend from "./src/components/icons/Recommend.astro";
import Suggest from "./src/components/icons/Suggest.astro";

## Custom Modules

### One Custom Module Per Object Type

<Recommend />

- Create a single [Custom Module](https://docs.xperience.io/x/Q4XWCQ) to handle [global events](https://docs.xperience.io/x/r4t1CQ) for a type (custom or system Object Type, Content Type)
- Register [event handlers](https://docs.xperience.io/x/r4t1CQ)
- Organize modules by feature

**Why?**

Since Global Events can be handled in any Custom Module class, the logic for handling these events can accidentally be spread all over a code base.
By creating one Custom Module per Object Type, we centralize handling for events for those objects.

**Why?**

Centralized event handling is easier to debug and abides by the [principle of lease surprise](https://ardalis.com/principle-of-least-surprise/)
because disabling a single module should disable all custom event handling for that object type.

**Why?**

If you have multiple custom Object Types in a [Custom Module](https://docs.xperience.io/xp/developers-and-admins/customization/object-types#Objecttypes-Createamodule)
within the Admin UI, you should also co-locate these Object Types together in your code.

### Single Module for All Document and Workflow Events

<Recommend />

- Create a single [Custom Module](https://docs.xperience.io/xp/developers-and-admins/customization/run-code-on-application-startup#Runcodeonapplicationstartup-Runcustomcodeonapplicationstartups) class
- Factor out specific Content Type event handling to separate non-static classes

**Why?**

Global events call their handlers in the order that they were registered, but this order can be very difficult to predict
when event handlers are registered in different [Custom Modules](https://docs.xperience.io/x/Q4XWCQ).
This becomes an issue when multiple event handlers might modify the same Content Item for a single Content Type event.

To make the order of executing of event handlers more predictable, register them all in a single class.

```csharp
[assembly: RegisterModule(typeof(PageGlobalEventsModule))]

namespace Sandbox.Xperience.Admin
{
    public class PageGlobalEventsModule : Module
    {
        public PageGlobalEventsModule() : base(nameof(PageGlobalEventsModule)) { }

        protected override void OnInit()
        {
            base.OnInit();

            DocumentEvents.Insert.Before += Insert_Before;
            DocumentEvents.Delete.Before += Delete_Before;
            WorkflowEvents.SaveVersion.Before += SaveVersion_Before;
        }

        private void Insert_Before(object sender, DocumentEventArgs e)
        {
            new HomePageEventsHandler().Insert_Before(sender, e);
            new PublicPageEventsHandler(Log).Insert_Before(sender, e);
            new NavigationPageEventsHandler().Insert_Before(sender, e);
        }

        private void Delete_Before(object sender, DocumentEventArgs e)
        {
            // ...
        }

        private void SaveVersion_After(object sender, WorkflowEventArgs e)
        {
            // ...
        }

        private IEventLogService Log => Service.Resolve<IEventLogService>();
    }
}
```

**Why?**

Event handler classes can be created for each Content Type (or each group of Content Types)
and organized with those generated Content Type classes to make them easy to find.
Making these handler methods non-static will also make them more testable and
help avoid captured global state (`static` class fields or properties):

```csharp
namespace Sandbox.Xperience.Common
{
    public class PublicPageEventsHandler
    {
        private readonly IEventLogService log;

        public PublicPageEventsHandler(IEventLogService log) => this.log = log;

        public void Insert_Before(object sender, DocumentEventArgs e)
        {
            if (!IsValidDocument(e.Node))
            {
                return;
            }

            SetDefaultValues(e.Node);
        }

        public void Update_Before(object sender, DocumentEventArgs e)
        {
            if (!IsValidDocument(e.Node))
            {
                return;
            }

            SetDefaultValues(e.Node);
        }

        private void SetDefaultValues(TreeNode node)
        {
            // ...
        }

        private bool IsValidDocument(TreeNode node) =>
            // ...
    }
}
```
